# -*- Makefile -*-
#----------------------------------------------------------------------------
#       GNU Makefile
#
# @file GNUmakefile.TAO_Core_idl
#
# $Id: gnu.mpd 95691 2012-04-10 20:11:35Z mitza $
#
# This file was automatically generated by MPC.  Any changes made directly to
# this file will be lost the next time it is generated.
#
#----------------------------------------------------------------------------
MAKEFILE         = GNUmakefile.TAO_Core_idl
DEPENDENCY_FILE  = .depend.TAO_Core_idl


LIB_PREFIX      ?= lib

FILES = \


#----------------------------------------------------------------------------
#       Include macros and targets
#----------------------------------------------------------------------------
TAO_IDL = ../../bin/tao_idl
TAO_IDL_DEP = ../../bin/tao_idl$(EXEEXT)
TAO_IDLFLAGS = -Wb,pre_include=ace/pre.h -Wb,post_include=ace/post.h -I..$(if $(ARCH), -g $(call ADD_QUOTE,$(call ADD_ARCH,$(ACE_ROOT)/bin/ace_gperf)))

PRJ_TYPE = library

COLLAPSE_SLASHES = $(if $(findstring //,$(1)),$(call COLLAPSE_SLASHES,$(subst //,/,$(1))),$(1))
INSLIB ?= $(call COLLAPSE_SLASHES,.)
ifeq ($(INSLIB),.)
  ifeq ($(CURDIR),)
    ifeq ($(PWD),)
      PWD=$(shell pwd)
    endif
  else
    PWD=$(CURDIR)
  endif
  INSLIB = $(PWD)
endif
OUTPUT_DIRECTORY = $(INSLIB)

include $(ACE_ROOT)/include/makeinclude/wrapper_macros.GNU


GNUACE_PROJECT_VERSION ?= $(ACE_VERSION)

# To build multiple targets in the same directory on AIX, it works
# best to have a template directory per project.
# The compiler/linker isn't too smart about instantiating templates...
ifdef TEMPINCDIR
TEMPINCDIR := $(TEMPINCDIR)/TAO_Core_idl
all: $(TEMPINCDIR)
endif

ifneq ($(OUTPUT_DIRECTORY),)
.PHONY: create_output_directory.local
all: create_output_directory.local
create_output_directory.local:
	-@$(MKDIR) "$(OUTPUT_DIRECTORY)" $(ACE_NUL_STDERR)
endif

LIBCHECK = 1
ifneq ($(LIBCHECK), 1)
  all: lib_warning
endif


include $(ACE_ROOT)/include/makeinclude/macros.GNU
include $(ACE_ROOT)/include/makeinclude/rules.common.GNU
include $(ACE_ROOT)/include/makeinclude/rules.nonested.GNU
include $(ACE_ROOT)/include/makeinclude/rules.local.GNU
ifeq ($(VXWORKSLINK),1)
include $(TGT_DIR)/h/make/rules.$(PRJ_TYPE)
endif

ifeq ($(VXWORKSLINK),1)
LDLIBPATH     = -L.
else
LDFLAGS      += -L. $(if $(ARCH),-L./$(ARCH))
endif

#----------------------------------------------------------------------------
#       Local targets
#----------------------------------------------------------------------------
lib_warning:
	@echo TAO_Core_idl will not be built due to the following missing library: $(LIBCHECK) >&2

## Some OS's have /bin/test others only have /usr/bin/test
ifeq ($(wildcard /bin/test), /bin/test)
  TEST_EXE = /bin/test
else
ifeq ($(wildcard /usr/bin/test), /usr/bin/test)
  TEST_EXE = /usr/bin/test
endif
endif

SPACE = $(should_be_unset) $(should_be_unset)
DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
LD_LIBRARY_PATH   := $(LD_LIBRARY_PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
SHLIB_PATH        := $(SHLIB_PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
LIBPATH           := $(LIBPATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
PATH              := $(PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))

GENERATED_DIRTY += GIOPC.inl GIOPS.h GIOPC.h AnyTypeCode/GIOPA.h GIOPC.cpp AnyTypeCode/GIOPA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "GIOP.pidl" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
GIOPC.inl GIOPS.h GIOPC.h AnyTypeCode/GIOPA.h GIOPC.cpp AnyTypeCode/GIOPA.cpp: GIOP.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h GIOP.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
GIOPC.inl GIOPS.h GIOPC.h AnyTypeCode/GIOPA.h GIOPC.cpp AnyTypeCode/GIOPA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += CONV_FRAMES.h CONV_FRAMEC.h AnyTypeCode/CONV_FRAMEA.h CONV_FRAMEC.cpp AnyTypeCode/CONV_FRAMEA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CONV_FRAME.pidl" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CONV_FRAMES.h CONV_FRAMEC.h AnyTypeCode/CONV_FRAMEA.h CONV_FRAMEC.cpp AnyTypeCode/CONV_FRAMEA.cpp: CONV_FRAME.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci CONV_FRAME.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
CONV_FRAMES.h CONV_FRAMEC.h AnyTypeCode/CONV_FRAMEA.h CONV_FRAMEC.cpp AnyTypeCode/CONV_FRAMEA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += CurrentS.h CurrentC.h AnyTypeCode/CurrentA.h CurrentC.cpp AnyTypeCode/CurrentA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Current.pidl" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CurrentS.h CurrentC.h AnyTypeCode/CurrentA.h CurrentC.cpp AnyTypeCode/CurrentA.cpp: Current.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Current.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
CurrentS.h CurrentC.h AnyTypeCode/CurrentA.h CurrentC.cpp AnyTypeCode/CurrentA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += IIOPS.h IIOPC.h AnyTypeCode/IIOPA.h IIOPC.cpp AnyTypeCode/IIOPA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "IIOP.pidl" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
IIOPS.h IIOPC.h AnyTypeCode/IIOPA.h IIOPC.cpp AnyTypeCode/IIOPA.cpp: IIOP.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci IIOP.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
IIOPS.h IIOPC.h AnyTypeCode/IIOPA.h IIOPC.cpp AnyTypeCode/IIOPA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += IIOP_EndpointsS.h IIOP_EndpointsC.h AnyTypeCode/IIOP_EndpointsA.h IIOP_EndpointsC.cpp AnyTypeCode/IIOP_EndpointsA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
IIOP_EndpointsS.h IIOP_EndpointsC.h AnyTypeCode/IIOP_EndpointsA.h IIOP_EndpointsC.cpp AnyTypeCode/IIOP_EndpointsA.cpp: IIOP_Endpoints.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci IIOP_Endpoints.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
IIOP_EndpointsS.h IIOP_EndpointsC.h AnyTypeCode/IIOP_EndpointsA.h IIOP_EndpointsC.cpp AnyTypeCode/IIOP_EndpointsA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += IOPS.h IOPC.h AnyTypeCode/IOPA.h IOPC.cpp AnyTypeCode/IOPA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "IOP.pidl" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
IOPS.h IOPC.h AnyTypeCode/IOPA.h IOPC.cpp AnyTypeCode/IOPA.cpp: IOP.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci IOP.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
IOPS.h IOPC.h AnyTypeCode/IOPA.h IOPC.cpp AnyTypeCode/IOPA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Messaging_PolicyValueS.h Messaging_PolicyValueC.h AnyTypeCode/Messaging_PolicyValueA.h Messaging_PolicyValueC.cpp AnyTypeCode/Messaging_PolicyValueA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Messaging_PolicyValueS.h Messaging_PolicyValueC.h AnyTypeCode/Messaging_PolicyValueA.h Messaging_PolicyValueC.cpp AnyTypeCode/Messaging_PolicyValueA.cpp: Messaging_PolicyValue.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Messaging_PolicyValue.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Messaging_PolicyValueS.h Messaging_PolicyValueC.h AnyTypeCode/Messaging_PolicyValueA.h Messaging_PolicyValueC.cpp AnyTypeCode/Messaging_PolicyValueA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Messaging_SyncScopeS.h Messaging_SyncScopeC.h AnyTypeCode/Messaging_SyncScopeA.h Messaging_SyncScopeC.cpp AnyTypeCode/Messaging_SyncScopeA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Messaging_SyncScopeS.h Messaging_SyncScopeC.h AnyTypeCode/Messaging_SyncScopeA.h Messaging_SyncScopeC.cpp AnyTypeCode/Messaging_SyncScopeA.cpp: Messaging_SyncScope.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Messaging_SyncScope.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Messaging_SyncScopeS.h Messaging_SyncScopeC.h AnyTypeCode/Messaging_SyncScopeA.h Messaging_SyncScopeC.cpp AnyTypeCode/Messaging_SyncScopeA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ObjectIdListS.h ObjectIdListC.h AnyTypeCode/ObjectIdListA.h ObjectIdListC.cpp AnyTypeCode/ObjectIdListA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ObjectIdList.pidl" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ObjectIdListS.h ObjectIdListC.h AnyTypeCode/ObjectIdListA.h ObjectIdListC.cpp AnyTypeCode/ObjectIdListA.cpp: ObjectIdList.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci ObjectIdList.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ObjectIdListS.h ObjectIdListC.h AnyTypeCode/ObjectIdListA.h ObjectIdListC.cpp AnyTypeCode/ObjectIdListA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += orb_typesS.h orb_typesC.h AnyTypeCode/orb_typesA.h orb_typesC.cpp AnyTypeCode/orb_typesA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "orb_types.pidl" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
orb_typesS.h orb_typesC.h AnyTypeCode/orb_typesA.h orb_typesC.cpp AnyTypeCode/orb_typesA.cpp: orb_types.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci orb_types.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
orb_typesS.h orb_typesC.h AnyTypeCode/orb_typesA.h orb_typesC.cpp AnyTypeCode/orb_typesA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Policy_ManagerS.h Policy_ManagerC.h AnyTypeCode/Policy_ManagerA.h Policy_ManagerC.cpp AnyTypeCode/Policy_ManagerA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy_Manager.pidl" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Policy_ManagerS.h Policy_ManagerC.h AnyTypeCode/Policy_ManagerA.h Policy_ManagerC.cpp AnyTypeCode/Policy_ManagerA.cpp: Policy_Manager.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Policy_Manager.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Policy_ManagerS.h Policy_ManagerC.h AnyTypeCode/Policy_ManagerA.h Policy_ManagerC.cpp AnyTypeCode/Policy_ManagerA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Policy_CurrentS.h Policy_CurrentC.h AnyTypeCode/Policy_CurrentA.h Policy_CurrentC.cpp AnyTypeCode/Policy_CurrentA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy_Current.pidl" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Policy_CurrentS.h Policy_CurrentC.h AnyTypeCode/Policy_CurrentA.h Policy_CurrentC.cpp AnyTypeCode/Policy_CurrentA.cpp: Policy_Current.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Policy_Current.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Policy_CurrentS.h Policy_CurrentC.h AnyTypeCode/Policy_CurrentA.h Policy_CurrentC.cpp AnyTypeCode/Policy_CurrentA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PI_ForwardS.h PI_ForwardC.h AnyTypeCode/PI_ForwardA.h PI_ForwardC.cpp AnyTypeCode/PI_ForwardA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "PI_Forward.pidl" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PI_ForwardS.h PI_ForwardC.h AnyTypeCode/PI_ForwardA.h PI_ForwardC.cpp AnyTypeCode/PI_ForwardA.cpp: PI_Forward.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci PI_Forward.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PI_ForwardS.h PI_ForwardC.h AnyTypeCode/PI_ForwardA.h PI_ForwardC.cpp AnyTypeCode/PI_ForwardA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PortableInterceptorS.h PortableInterceptorC.h AnyTypeCode/PortableInterceptorA.h PortableInterceptorC.cpp AnyTypeCode/PortableInterceptorA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "PortableInterceptor.pidl" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PortableInterceptorS.h PortableInterceptorC.h AnyTypeCode/PortableInterceptorA.h PortableInterceptorC.cpp AnyTypeCode/PortableInterceptorA.cpp: PortableInterceptor.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci PortableInterceptor.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PortableInterceptorS.h PortableInterceptorC.h AnyTypeCode/PortableInterceptorA.h PortableInterceptorC.cpp AnyTypeCode/PortableInterceptorA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ServicesS.h ServicesC.h AnyTypeCode/ServicesA.h ServicesC.cpp AnyTypeCode/ServicesA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Services.pidl" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ServicesS.h ServicesC.h AnyTypeCode/ServicesA.h ServicesC.cpp AnyTypeCode/ServicesA.cpp: Services.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Services.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ServicesS.h ServicesC.h AnyTypeCode/ServicesA.h ServicesC.cpp AnyTypeCode/ServicesA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += TAOS.h TAOC.h AnyTypeCode/TAOA.h TAOC.cpp AnyTypeCode/TAOA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "TAO.pidl" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
TAOS.h TAOC.h AnyTypeCode/TAOA.h TAOC.cpp AnyTypeCode/TAOA.cpp: TAO.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci TAO.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
TAOS.h TAOC.h AnyTypeCode/TAOA.h TAOC.cpp AnyTypeCode/TAOA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += TimeBaseS.h TimeBaseC.h AnyTypeCode/TimeBaseA.h TimeBaseC.cpp AnyTypeCode/TimeBaseA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "TimeBase.pidl" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
TimeBaseS.h TimeBaseC.h AnyTypeCode/TimeBaseA.h TimeBaseC.cpp AnyTypeCode/TimeBaseA.cpp: TimeBase.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci TimeBase.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
TimeBaseS.h TimeBaseC.h AnyTypeCode/TimeBaseA.h TimeBaseC.cpp AnyTypeCode/TimeBaseA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Policy_ForwardS.h Policy_ForwardC.h AnyTypeCode/Policy_ForwardA.h Policy_ForwardC.cpp AnyTypeCode/Policy_ForwardA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy_Forward.pidl" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Policy_ForwardS.h Policy_ForwardC.h AnyTypeCode/Policy_ForwardA.h Policy_ForwardC.cpp AnyTypeCode/Policy_ForwardA.cpp: Policy_Forward.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Sa Policy_Forward.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Policy_ForwardS.h Policy_ForwardC.h AnyTypeCode/Policy_ForwardA.h Policy_ForwardC.cpp AnyTypeCode/Policy_ForwardA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ParameterModeS.h ParameterModeC.h AnyTypeCode/ParameterModeA.h ParameterModeC.cpp AnyTypeCode/ParameterModeA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ParameterMode.pidl" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ParameterModeS.h ParameterModeC.h AnyTypeCode/ParameterModeA.h ParameterModeC.cpp AnyTypeCode/ParameterModeA.cpp: ParameterMode.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Sat ParameterMode.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ParameterModeS.h ParameterModeC.h AnyTypeCode/ParameterModeA.h ParameterModeC.cpp AnyTypeCode/ParameterModeA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += BooleanSeqS.h BooleanSeqC.h AnyTypeCode/BooleanSeqA.h BooleanSeqC.cpp AnyTypeCode/BooleanSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "BooleanSeq.pidl" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
BooleanSeqS.h BooleanSeqC.h AnyTypeCode/BooleanSeqA.h BooleanSeqC.cpp AnyTypeCode/BooleanSeqA.cpp: BooleanSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata BooleanSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
BooleanSeqS.h BooleanSeqC.h AnyTypeCode/BooleanSeqA.h BooleanSeqC.cpp AnyTypeCode/BooleanSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += CharSeqS.h CharSeqC.h AnyTypeCode/CharSeqA.h CharSeqC.cpp AnyTypeCode/CharSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CharSeq.pidl" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CharSeqS.h CharSeqC.h AnyTypeCode/CharSeqA.h CharSeqC.cpp AnyTypeCode/CharSeqA.cpp: CharSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata CharSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
CharSeqS.h CharSeqC.h AnyTypeCode/CharSeqA.h CharSeqC.cpp AnyTypeCode/CharSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += DoubleSeqS.h DoubleSeqC.h AnyTypeCode/DoubleSeqA.h DoubleSeqC.cpp AnyTypeCode/DoubleSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DoubleSeq.pidl" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DoubleSeqS.h DoubleSeqC.h AnyTypeCode/DoubleSeqA.h DoubleSeqC.cpp AnyTypeCode/DoubleSeqA.cpp: DoubleSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata DoubleSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DoubleSeqS.h DoubleSeqC.h AnyTypeCode/DoubleSeqA.h DoubleSeqC.cpp AnyTypeCode/DoubleSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += FloatSeqS.h FloatSeqC.h AnyTypeCode/FloatSeqA.h FloatSeqC.cpp AnyTypeCode/FloatSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "FloatSeq.pidl" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
FloatSeqS.h FloatSeqC.h AnyTypeCode/FloatSeqA.h FloatSeqC.cpp AnyTypeCode/FloatSeqA.cpp: FloatSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata FloatSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
FloatSeqS.h FloatSeqC.h AnyTypeCode/FloatSeqA.h FloatSeqC.cpp AnyTypeCode/FloatSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += LongDoubleSeqS.h LongDoubleSeqC.h AnyTypeCode/LongDoubleSeqA.h LongDoubleSeqC.cpp AnyTypeCode/LongDoubleSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "LongDoubleSeq.pidl" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
LongDoubleSeqS.h LongDoubleSeqC.h AnyTypeCode/LongDoubleSeqA.h LongDoubleSeqC.cpp AnyTypeCode/LongDoubleSeqA.cpp: LongDoubleSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata LongDoubleSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
LongDoubleSeqS.h LongDoubleSeqC.h AnyTypeCode/LongDoubleSeqA.h LongDoubleSeqC.cpp AnyTypeCode/LongDoubleSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += LongLongSeqS.h LongLongSeqC.h AnyTypeCode/LongLongSeqA.h LongLongSeqC.cpp AnyTypeCode/LongLongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "LongLongSeq.pidl" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
LongLongSeqS.h LongLongSeqC.h AnyTypeCode/LongLongSeqA.h LongLongSeqC.cpp AnyTypeCode/LongLongSeqA.cpp: LongLongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata LongLongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
LongLongSeqS.h LongLongSeqC.h AnyTypeCode/LongLongSeqA.h LongLongSeqC.cpp AnyTypeCode/LongLongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += LongSeqS.h LongSeqC.h AnyTypeCode/LongSeqA.h LongSeqC.cpp AnyTypeCode/LongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "LongSeq.pidl" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
LongSeqS.h LongSeqC.h AnyTypeCode/LongSeqA.h LongSeqC.cpp AnyTypeCode/LongSeqA.cpp: LongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata LongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
LongSeqS.h LongSeqC.h AnyTypeCode/LongSeqA.h LongSeqC.cpp AnyTypeCode/LongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += OctetSeqS.h OctetSeqC.h AnyTypeCode/OctetSeqA.h OctetSeqC.cpp AnyTypeCode/OctetSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "OctetSeq.pidl" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
OctetSeqS.h OctetSeqC.h AnyTypeCode/OctetSeqA.h OctetSeqC.cpp AnyTypeCode/OctetSeqA.cpp: OctetSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata OctetSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
OctetSeqS.h OctetSeqC.h AnyTypeCode/OctetSeqA.h OctetSeqC.cpp AnyTypeCode/OctetSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ShortSeqS.h ShortSeqC.h AnyTypeCode/ShortSeqA.h ShortSeqC.cpp AnyTypeCode/ShortSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ShortSeq.pidl" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ShortSeqS.h ShortSeqC.h AnyTypeCode/ShortSeqA.h ShortSeqC.cpp AnyTypeCode/ShortSeqA.cpp: ShortSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata ShortSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ShortSeqS.h ShortSeqC.h AnyTypeCode/ShortSeqA.h ShortSeqC.cpp AnyTypeCode/ShortSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += StringSeqS.h StringSeqC.h AnyTypeCode/StringSeqA.h StringSeqC.cpp AnyTypeCode/StringSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "StringSeq.pidl" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
StringSeqS.h StringSeqC.h AnyTypeCode/StringSeqA.h StringSeqC.cpp AnyTypeCode/StringSeqA.cpp: StringSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata StringSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
StringSeqS.h StringSeqC.h AnyTypeCode/StringSeqA.h StringSeqC.cpp AnyTypeCode/StringSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ULongLongSeqS.h ULongLongSeqC.h AnyTypeCode/ULongLongSeqA.h ULongLongSeqC.cpp AnyTypeCode/ULongLongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ULongLongSeq.pidl" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ULongLongSeqS.h ULongLongSeqC.h AnyTypeCode/ULongLongSeqA.h ULongLongSeqC.cpp AnyTypeCode/ULongLongSeqA.cpp: ULongLongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata ULongLongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ULongLongSeqS.h ULongLongSeqC.h AnyTypeCode/ULongLongSeqA.h ULongLongSeqC.cpp AnyTypeCode/ULongLongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ULongSeqS.h ULongSeqC.h AnyTypeCode/ULongSeqA.h ULongSeqC.cpp AnyTypeCode/ULongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ULongSeq.pidl" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ULongSeqS.h ULongSeqC.h AnyTypeCode/ULongSeqA.h ULongSeqC.cpp AnyTypeCode/ULongSeqA.cpp: ULongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata ULongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ULongSeqS.h ULongSeqC.h AnyTypeCode/ULongSeqA.h ULongSeqC.cpp AnyTypeCode/ULongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += UShortSeqS.h UShortSeqC.h AnyTypeCode/UShortSeqA.h UShortSeqC.cpp AnyTypeCode/UShortSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "UShortSeq.pidl" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
UShortSeqS.h UShortSeqC.h AnyTypeCode/UShortSeqA.h UShortSeqC.cpp AnyTypeCode/UShortSeqA.cpp: UShortSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata UShortSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
UShortSeqS.h UShortSeqC.h AnyTypeCode/UShortSeqA.h UShortSeqC.cpp AnyTypeCode/UShortSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += WCharSeqS.h WCharSeqC.h AnyTypeCode/WCharSeqA.h WCharSeqC.cpp AnyTypeCode/WCharSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "WCharSeq.pidl" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
WCharSeqS.h WCharSeqC.h AnyTypeCode/WCharSeqA.h WCharSeqC.cpp AnyTypeCode/WCharSeqA.cpp: WCharSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata WCharSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
WCharSeqS.h WCharSeqC.h AnyTypeCode/WCharSeqA.h WCharSeqC.cpp AnyTypeCode/WCharSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += WStringSeqS.h WStringSeqC.h AnyTypeCode/WStringSeqA.h WStringSeqC.cpp AnyTypeCode/WStringSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "WStringSeq.pidl" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
WStringSeqS.h WStringSeqC.h AnyTypeCode/WStringSeqA.h WStringSeqC.cpp AnyTypeCode/WStringSeqA.cpp: WStringSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata WStringSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
WStringSeqS.h WStringSeqC.h AnyTypeCode/WStringSeqA.h WStringSeqC.cpp AnyTypeCode/WStringSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PolicyC.inl PolicyC.h PortableServer/PolicyS.h PolicyC.cpp PortableServer/PolicyS.cpp PortableServer/PolicyS_T.cpp PortableServer/PolicyS_T.h AnyTypeCode/PolicyA.h AnyTypeCode/PolicyA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy.pidl" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PolicyC.inl PolicyC.h PortableServer/PolicyS.h PolicyC.cpp PortableServer/PolicyS.cpp PortableServer/PolicyS_T.cpp PortableServer/PolicyS_T.h AnyTypeCode/PolicyA.h AnyTypeCode/PolicyA.cpp: Policy.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -GT -oS PortableServer -Gd -Wb,safe_include=tao/PolicyC.h -Wb,skel_export_macro=TAO_PortableServer_Export -Wb,skel_export_include=tao/PortableServer/portableserver_export.h Policy.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PolicyC.inl PolicyC.h PortableServer/PolicyS.h PolicyC.cpp PortableServer/PolicyS.cpp PortableServer/PolicyS_T.cpp PortableServer/PolicyS_T.h AnyTypeCode/PolicyA.h AnyTypeCode/PolicyA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

ifneq ($(GENERATED_DIRTY),)
.PRECIOUS: $(GENERATED_DIRTY)
all: $(GENERATED_DIRTY)
endif

ADDITIONAL_IDL_TARGETS += GIOP$(IDL_CLIENT_HDR_EXT) CONV_FRAME$(IDL_CLIENT_HDR_EXT) Current$(IDL_CLIENT_HDR_EXT) IIOP$(IDL_CLIENT_HDR_EXT) IIOP_Endpoints$(IDL_CLIENT_HDR_EXT) IOP$(IDL_CLIENT_HDR_EXT) Messaging_PolicyValue$(IDL_CLIENT_HDR_EXT) Messaging_SyncScope$(IDL_CLIENT_HDR_EXT) ObjectIdList$(IDL_CLIENT_HDR_EXT) orb_types$(IDL_CLIENT_HDR_EXT) Policy_Manager$(IDL_CLIENT_HDR_EXT) Policy_Current$(IDL_CLIENT_HDR_EXT) PI_Forward$(IDL_CLIENT_HDR_EXT) PortableInterceptor$(IDL_CLIENT_HDR_EXT) Services$(IDL_CLIENT_HDR_EXT) TAO$(IDL_CLIENT_HDR_EXT) TimeBase$(IDL_CLIENT_HDR_EXT) Policy_Forward$(IDL_CLIENT_HDR_EXT) ParameterMode$(IDL_CLIENT_HDR_EXT) BooleanSeq$(IDL_CLIENT_HDR_EXT) CharSeq$(IDL_CLIENT_HDR_EXT) DoubleSeq$(IDL_CLIENT_HDR_EXT) FloatSeq$(IDL_CLIENT_HDR_EXT) LongDoubleSeq$(IDL_CLIENT_HDR_EXT) LongLongSeq$(IDL_CLIENT_HDR_EXT) LongSeq$(IDL_CLIENT_HDR_EXT) OctetSeq$(IDL_CLIENT_HDR_EXT) ShortSeq$(IDL_CLIENT_HDR_EXT) StringSeq$(IDL_CLIENT_HDR_EXT) ULongLongSeq$(IDL_CLIENT_HDR_EXT) ULongSeq$(IDL_CLIENT_HDR_EXT) UShortSeq$(IDL_CLIENT_HDR_EXT) WCharSeq$(IDL_CLIENT_HDR_EXT) WStringSeq$(IDL_CLIENT_HDR_EXT) Policy$(IDL_CLIENT_HDR_EXT)
idl_stubs: $(ADDITIONAL_IDL_TARGETS)


realclean: clean
ifneq ($(GENERATED_DIRTY),)
	-$(RM) -r $(GENERATED_DIRTY)
endif

__prebuild__:
	@-:


.PHONY: install
install: all
INSTALL_LIB ?= lib
ifneq ($(INSTALL_PREFIX),)
ifneq ($(install_rpath),0)
LDFLAGS += -Wl,-R$(INSTALL_PREFIX)/$(INSTALL_LIB) $(LD_RPATH_FLAGS)
endif
endif

PRJINST_OPTIONS ?=
INST_DIR ?= /$(notdir $(PWD))
COMMA = ,
SPACE = $(should_be_unset) $(should_be_unset)
INSTALLER ?= $(MPC_ROOT)/prj_install.pl
CUSTOM_INST_TAGS = $(sort pidlinstallwithoutbuilding_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files )

INST_TAGS = $(CUSTOM_INST_TAGS)
INST_LOCATIONS = $(foreach tag,$(INST_TAGS),-b $(tag)=include$(INST_DIR))

DATA_INST_TAGS = 
INST_LOCATIONS += $(if $(DATA_INST_TAGS),-x installdata_files -b installdata_files=share$(INST_DIR))
INST_TAGS := $(INST_TAGS)$(if $(DATA_INST_TAGS), $(DATA_INST_TAGS))

ifeq ($(INSTALLER),/prj_install.pl)
INSTALLER = $(ACE_ROOT)/MPC/prj_install.pl
endif

ifeq ($(LIBCHECK),1)
install:
ifeq ($(INST_TAGS),)
	@echo Nothing to install.
else
ifeq ($(INSTALL_PREFIX),)
	@echo The variable INSTALL_PREFIX must be set to install.
	@echo If binaries are already built and you want to use RPATH,
	@echo they must be rebuilt after changing INSTALL_PREFIX.
	@false
else
	perl -ne'if (/^#END MPC-Generated Install Info/) {exit 0}' \
	  -e'elsif (/^#BEGIN MPC-Generated Install Info/) {$$ok=1}' \
	  -e'elsif ($$ok && s/^#//) {print}' $(MAKEFILE) | \
	$(INSTALLER) -i -s $(subst $(SPACE),$(COMMA),$(INST_TAGS)) \
	  $(INST_LOCATIONS) $(if $(ARCH),-d $(ARCH)) $(PRJINST_OPTIONS) \
	  $(DESTDIR)$(INSTALL_PREFIX)
endif
endif
endif

#BEGIN MPC-Generated Install Info
#build_files:
#tao.mpc
#extra_core.mpb
#tao.mwc
#
#idl_files:
#GIOP.pidl
#CONV_FRAME.pidl
#Current.pidl
#IIOP.pidl
#IIOP_Endpoints.pidl
#IOP.pidl
#Messaging_PolicyValue.pidl
#Messaging_SyncScope.pidl
#ObjectIdList.pidl
#orb_types.pidl
#Policy_Manager.pidl
#Policy_Current.pidl
#PI_Forward.pidl
#PortableInterceptor.pidl
#Services.pidl
#TAO.pidl
#TimeBase.pidl
#Policy_Forward.pidl
#ParameterMode.pidl
#BooleanSeq.pidl
#CharSeq.pidl
#DoubleSeq.pidl
#FloatSeq.pidl
#LongDoubleSeq.pidl
#LongLongSeq.pidl
#LongSeq.pidl
#OctetSeq.pidl
#ShortSeq.pidl
#StringSeq.pidl
#ULongLongSeq.pidl
#ULongSeq.pidl
#UShortSeq.pidl
#WCharSeq.pidl
#WStringSeq.pidl
#Policy.pidl
#
#pidlinstallwithoutbuilding_files:
#InterfaceDef.pidl
#InvalidName.pidl
#Object_Key.pidl
#Typecode_types.pidl
#WrongTransaction.pidl
#orb.idl
#

#END MPC-Generated Install Info

